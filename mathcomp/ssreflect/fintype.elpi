  /*
  pred finp i:term, i:term, o:term.

  finp {{ (fun x => lp:(F x)) lp:A }} X Proof :- finp (F A) X Proof.

  finp {{ finpred lp:P lp:X }} X {{ pred_enumP lp:P }}.
  
  finp {{ in_mem lp:X (mem (finpred lp:P)) }} X {{ pred_enumP lp:P }}.

  finp {{ in_mem lp:X (mem lp:A) }} X {{ fun x => erefl }}.
  
  finp {{ lp:Px && lp:Qx }} X Proof :-
    finp Px X ProofP, anyp Qx X Q,
    Proof = {{ applicationI_subproof2 lp:Q lp:ProofP }}.

  finp {{ lp:Px || lp:Qx }} X Proof :-
    finp Px X ProofP, finp Qx X ProofQ,
    Proof = {{ applicationU_subproof2 lp:ProofP lp:ProofQ }}.

  finp Px X Proof :-
    coq.typecheck X Ty ok,
    coq.unify-eq Ty {{ Finite.sort _ }} ok,
    anyp Px X P,
    Proof = {{ setT_comprehension_subproof lp:P }}.

  finp (app[global (const C)|Args]) X Proof :-
    coq.env.const C (some Body) _,
    coq.mk-app Body Args Redex,
    % TODO: simulate exactly what evarconv does
    @redflags! coq.redflags.betaiotazeta =>
      coq.reduction.lazy.whd Redex TRed,
    if (TRed = match T P BS, whd1 T T1)
       (@redflags! coq.redflags.betaiotazeta =>
          coq.reduction.lazy.whd (match T1 P BS) Next)
       (Next = TRed),

    coq.say "unfolding" C "gives" {coq.term->string Next},
    finp Next X Proof.

  pred anyp i:term, i:term, o:term.
  anyp T X {{ fun x => lp:(P x) }} :-
    pi x\ copy X x => copy T (P x).
    % var P _ L, std.filter L (x\not(x = X)) L', prune P L', T = P X.
  */
  pred find i:term, o:term.
  find {{ simpl_of_mem (@mem lp:FT _ lp:P) }} _ :- coq.error "TODO".
  find {{ PredOfSimpl.coerce (SimplPred lp:P) }} Proof :-
    find P Proof.
  find P Proof :-
    std.assert-ok! (coq.unify-eq P {{ fun x => @apply_val _ lp:ApplyP x }})
      "cannot find Apply",
    Proof = {{ @pred_eqset _ lp:ApplyP }}.

  % find {{ fun x : lp:T => lp:(Bo x) }} Proof :-
  %   pi x\ decl x `x` T =>
  %     finp (Bo x) x Proof.

  solve (goal _ _ ({{ finPred_aux lp:Pred _ }} as Ty) _ [] as G) GL :-
    coq.say "Proving that" {coq.term->string Pred} "is finPred",
    % coq.say "Proving that" Pred "is finPred",
    find Pred Proof,
    FinalProof = {{ OK lp:Proof }},
    coq.say "Final proof" {coq.term->string FinalProof},
    std.assert-ok! (coq.typecheck FinalProof _) "illtyped proof",
    std.assert-ok! (coq.typecheck FinalProof Ty) "wrong proof",
    refine FinalProof G GL.
